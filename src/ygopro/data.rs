#![allow(dead_code)]
#![allow(non_upper_case_globals)]
use std::collections::HashMap;
use std::io::BufRead;
use std::io::Cursor;
use std::io::Read;

use byteorder::LittleEndian;
use byteorder::ReadBytesExt;
use lzma_rs::lzma_decompress_with_options;
use serde::Serialize;
use serde::Deserialize;
use sqlx::Connection;
use sqlx::Row;

use crate::ygopro::message::GreedyVector;
use crate::ygopro::message::string::cast_to_string;

#[derive(PartialEq, Eq, Debug, Clone, Default, Serialize, Deserialize)]
#[serde(from = "DeckBinaryStructure", into = "DeckBinaryStructure")]
pub struct Deck {
    pub main: Vec<u32>,
    pub side: Vec<u32>,
    pub ex: Vec<u32> // always empty
}

#[derive(serde::Serialize, serde::Deserialize)]
struct DeckBinaryStructure {
    pub main_count: usize,
    pub side_count: usize,
    #[serde(with = "GreedyVector::<90>")]
    pub deck_buffer: Vec<u32>
}

impl Deck {
    fn from_binary(data: &DeckBinaryStructure) -> Deck {
        Deck {
            main: data.deck_buffer[0..data.main_count].to_vec(),
            side: data.deck_buffer[data.main_count..data.main_count + data.side_count].to_vec(),
            ex: Vec::new()
        }
    }

    pub fn from_reader<T: byteorder::ReadBytesExt>(reader: &mut T) -> anyhow::Result<Deck> {
        Ok(Deck {
            main: read_array_with_length(reader)?,
            ex: read_array_with_length(reader)?,
            side: Vec::new()
        })
    }
}

impl core::convert::From<DeckBinaryStructure> for Deck {
    fn from(data: DeckBinaryStructure) -> Self {
        Deck::from_binary(&data) 
    }
}

impl core::convert::Into<DeckBinaryStructure> for Deck {
    fn into(mut self) -> DeckBinaryStructure {
        let main_count = self.main.len() + self.ex.len();
        let side_count = self.side.len();
        self.main.append(&mut self.ex);
        self.main.append(&mut self.side);
        DeckBinaryStructure {
            main_count,
            side_count,
            deck_buffer: self.main,
        }
    }
}

impl std::fmt::Display for Deck {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "#generated by srvpru deck log")?;
        writeln!(f, "#main")?;
        for card in self.main.iter() {  
            writeln!(f, "{:}", card)?;
        }
        writeln!(f, "!side")?;
        for card in self.side.iter() {
            writeln!(f, "{:}", card)?;
        }
        Ok(())
    }
}

pub const REPLAY_COMPRESSED_FLAG: u32 = 1;
pub const REPLAY_TAG_FLAG: u32 = 2;
pub const REPLAY_DECODE_FLAG: u32 = 4;
pub const REPLAY_SINGLE_MODE: u32 = 8;
pub const REPLAY_UNIFORM: u32 = 16;

bitflags! {
    pub struct ReplayHeaderFlags: u32 {
        const Compressed = 1;
        const Tag = 2;
        const Decode = 4;
        const SingleMode = 8;
        const Uniform = 16;
    }
}

pub struct ReplayHeader {
    pub id: u32,
    pub version: u32,
    pub flag: ReplayHeaderFlags,
    pub seed: u32,
    pub data_size: u32,
    pub start_time: u32,
    pub props: [u8; 8]
}

pub struct Replay {
    pub header: ReplayHeader,
    pub host_name: String,
    pub client_name: String,
    pub start_lp: u32,
    pub start_hand: u32,
    pub draw_count: u32,
    pub opt: u32,
    pub host_deck: Deck,
    pub client_deck: Deck,

    pub tag_host_name: Option<String>,
    pub tag_client_name: Option<String>,
    pub tag_host_deck: Option<Deck>,
    pub tag_client_deck: Option<Deck>,

    pub datas: Vec<Vec<u8>>
}

impl ReplayHeader {
    pub fn from_reader<T: ReadBytesExt>(reader: &mut T) -> anyhow::Result<ReplayHeader> {
        Ok(ReplayHeader {
            id: reader.read_u32::<LittleEndian>()?,
            version: reader.read_u32::<LittleEndian>()?,
            flag: ReplayHeaderFlags::from_bits_truncate(reader.read_u32::<LittleEndian>()?),
            seed: reader.read_u32::<LittleEndian>()?,
            data_size: reader.read_u32::<LittleEndian>()?,
            start_time: reader.read_u32::<LittleEndian>()?,
            props: read_array(reader)?,
        })
    }

    pub fn is_compressed(&self) -> bool { self.flag.contains(ReplayHeaderFlags::Compressed) }
    pub fn is_tag(&self)        -> bool { self.flag.contains(ReplayHeaderFlags::Tag) }
    pub fn is_decoded(&self)    -> bool { self.flag.contains(ReplayHeaderFlags::Decode) }
}

impl Replay {
    // ==================================================
    // Correct order: 
    // prop  dict_size  datasize
    //  93    0 0 0 1     u64
    // Ygopro replay header:
    // datasize  prop  dict_size  padding
    //   u32      93    0 0 0 1    0 0 0
    // ==================================================
    pub fn from_reader<T: ReadBytesExt + BufRead>(reader: &mut T) -> anyhow::Result<Replay> {
        let header = ReplayHeader::from_reader(reader)?; 
        let leading_props = Cursor::new(&header.props[0..5]);
        let mut compressed_data = leading_props.chain(reader);
        let mut decompressed_vector = Vec::new();
        lzma_decompress_with_options(&mut compressed_data, &mut decompressed_vector, &lzma_rs::decompress::Options { 
            unpacked_size: lzma_rs::decompress::UnpackedSize::UseProvided(Some(header.data_size as u64)), 
            memlimit: None,
            allow_incomplete: false 
        })?;
        let mut decompressed_reader = Cursor::new(decompressed_vector);
        let reader = &mut decompressed_reader;
        let is_tag = header.is_tag();
        let mut replay = Replay {
            header,
            host_name: read_string::<_, 20>(reader)?,
            tag_host_name: if is_tag { Some(read_string::<_, 20>(reader)?) } else { None },
            tag_client_name: if is_tag { Some(read_string::<_, 20>(reader)?) } else { None },
            client_name: read_string::<_, 20>(reader)?, 
            start_lp: reader.read_u32::<LittleEndian>()?,
            start_hand: reader.read_u32::<LittleEndian>()?,
            draw_count: reader.read_u32::<LittleEndian>()?,
            opt: reader.read_u32::<LittleEndian>()?,
            host_deck: Deck::from_reader(reader)?,
            tag_host_deck: if is_tag { Some(Deck::from_reader(reader)?) } else { None },
            tag_client_deck: if is_tag { Some(Deck::from_reader(reader)?) } else { None },
            client_deck: Deck::from_reader(reader)?,
            datas: Vec::new(),
        };
        loop {
            let length = reader.read_u8();
            if let Err(ref e) = length {
                if e.kind() == std::io::ErrorKind::UnexpectedEof {
                    break;
                }
            }
            let mut data = vec![0u8; length? as usize];
            reader.read_exact(&mut data)?;
            replay.datas.push(data);
        }
        Ok(replay)
    }
}

fn read_array<T: ReadBytesExt, const N: usize>(reader: &mut T) -> anyhow::Result<[u8; N]> {
    let mut arr = [0u8; N];
    for i in 0..N { arr[i] = reader.read_u8()?; }
    Ok(arr)
}

fn read_array_with_length<T: ReadBytesExt>(reader: &mut T) -> anyhow::Result<Vec<u32>> {
    let length = reader.read_u32::<LittleEndian>()?;
    let mut vec = Vec::new();
    for _ in 0..length as usize { vec.push(reader.read_u32::<LittleEndian>()?) }
    Ok(vec)
}

fn read_string<T: ReadBytesExt, const N: usize>(reader: &mut T) -> anyhow::Result<String> {
    let mut arr = [0u16; N];
    for i in 0..N { arr[i] = reader.read_u16::<LittleEndian>()?; }
    cast_to_string(&arr).ok_or(anyhow!("Cannot cast byte array to string"))
}

pub struct LFLists {
    lists: Vec<String>
}

impl LFLists {
    fn init(&mut self) -> std::io::Result<()> {
        let configuration = crate::srvpru::get_configuration();
        let file = std::fs::File::open(configuration.ygopro.lflist_conf.clone())?;
        for line in std::io::BufReader::new(file).lines() {
            let _line = line?;
            if _line.starts_with("!") {
                self.lists.push(_line[1..].to_string());
            }
        }
        Ok(())
    }

    pub fn first_tcg(&self) -> i32 {
        for (index, name) in self.lists.iter().enumerate() {
            if name.ends_with("TCG") {
                return index as i32;
            }
        }
        return -1;
    } 
}

lazy_static! {
    pub static ref LFLISTS: LFLists = {
        let mut lflists = LFLists { lists: Vec::new() };
        lflists.init().expect("Failed to initialize lflists");
        lflists
    };
}

pub struct Card {
    pub code: u32,
    pub alias: u32,
    pub setcode: i64,
    pub _type: crate::ygopro::Type,
    pub level: u32,
    pub attribute: crate::ygopro::Attribute,
    pub race: crate::ygopro::Race,
    pub attack: i32,
    pub defense: i32,
    pub left_scale: u32,
    pub right_scale: u32,
    pub link_marker: crate::ygopro::Linkmarkers
}

impl<'r> sqlx::FromRow<'r, sqlx::sqlite::SqliteRow> for Card {
    fn from_row(row: &'r sqlx::sqlite::SqliteRow) -> Result<Self, sqlx::Error> {
        let code = row.try_get("id")?;
        let alias = row.try_get("alias")?;
        let setcode = row.try_get("setcode")?;
        let _type = crate::ygopro::Type::from_bits_truncate(row.try_get("type")?);
        let _level: u32 = row.try_get("level")?;
        let level = _level & 0xff;
		let left_scale = (_level >> 24) & 0xff;
		let right_scale = (_level >> 16) & 0xff;
        let attribute = crate::ygopro::Attribute::from_bits_truncate(row.try_get("attribute")?);
        let race = crate::ygopro::Race::from_bits_truncate(row.try_get("race")?);
        let attack = row.try_get("atk")?;
        let _defense = row.try_get("def")?;
        let (defense, link_marker) = if _type.contains(crate::ygopro::Type::Link) {
            (0, crate::ygopro::Linkmarkers::from_bits_truncate(u32::try_from(_defense).ok().unwrap_or(0) ))
        }
        else {
            (_defense, crate::ygopro::Linkmarkers::empty())
        };

        Ok(Card{ 
            code,
            alias,
            setcode,
            _type,
            level,
            attribute,
            race,
            attack,
            defense,
            left_scale,
            right_scale,
            link_marker
        })
    }
}

impl Card {
    pub async fn load_all_cards() -> anyhow::Result<()> {
        let configuration = &crate::srvpru::get_configuration().ygopro;
        let path = std::path::Path::new(&configuration.cwd).join(&configuration.database);
        let path= path.to_str().ok_or(anyhow!("Path not legal"))?;
        Card::load_all_cards_from(path, "main").await?;
        Ok(())
    }

    pub async fn load_all_cards_from(path: &str, name: &str) -> anyhow::Result<()> {
        let mut conn = sqlx::SqliteConnection::connect(&("sqlite://".to_string() + path)).await?;
        let cards = sqlx::query_as::<_, Card>("SELECT * FROM datas").fetch_all(&mut conn).await?;
        Card::remove_cards(name);
        Card::add_cards(name, cards);
        Ok(())
    }

    pub fn remove_cards(name: &str) {
        if let Some(indexes) = CARD_INDEXES.lock().remove(name) {
            let mut cards = CARDS.write();
            for index in indexes.iter() {
                cards.remove(index);
            }
        }
    }

    pub fn add_cards(name: &str, cards: Vec<Card>) {
        let mut all_cards = CARDS.write();
        let mut all_card_indexes = CARD_INDEXES.lock();
        let mut card_indexes = Vec::new();
        for card in cards.into_iter() {
            card_indexes.push(card.code);
            all_cards.insert(card.code, card);
        }
        all_card_indexes.insert(name.to_string(), card_indexes);
    }
}

lazy_static! {
    pub static ref CARDS: parking_lot::RwLock<HashMap<u32, Card>> = parking_lot::RwLock::new(HashMap::new());
    static ref CARD_INDEXES: parking_lot::Mutex<HashMap<String, Vec<u32>>> = parking_lot::Mutex::new(HashMap::new());
}